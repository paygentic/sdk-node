/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { sourcesApproveSourceEvent } from "../funcs/sourcesApproveSourceEvent.js";
import { sourcesBulkApproveSourceEvents } from "../funcs/sourcesBulkApproveSourceEvents.js";
import { sourcesBulkRejectSourceEvents } from "../funcs/sourcesBulkRejectSourceEvents.js";
import { sourcesCreateSource } from "../funcs/sourcesCreateSource.js";
import { sourcesCreateSourceRule } from "../funcs/sourcesCreateSourceRule.js";
import { sourcesDeleteSourceRule } from "../funcs/sourcesDeleteSourceRule.js";
import { sourcesGetSource } from "../funcs/sourcesGetSource.js";
import { sourcesGetSourceRule } from "../funcs/sourcesGetSourceRule.js";
import { sourcesListSourceEvents } from "../funcs/sourcesListSourceEvents.js";
import { sourcesListSourceRules } from "../funcs/sourcesListSourceRules.js";
import { sourcesListSources } from "../funcs/sourcesListSources.js";
import { sourcesRejectSourceEvent } from "../funcs/sourcesRejectSourceEvent.js";
import { sourcesUpdateSource } from "../funcs/sourcesUpdateSource.js";
import { sourcesUpdateSourceRule } from "../funcs/sourcesUpdateSourceRule.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Sources extends ClientSDK {
  /**
   * Create
   *
   * @remarks
   * Create a new source for automated usage event generation from external data sources.
   */
  async createSource(
    request: operations.CreateSourceRequest,
    options?: RequestOptions,
  ): Promise<models.Source> {
    return unwrapAsync(sourcesCreateSource(
      this,
      request,
      options,
    ));
  }

  /**
   * List
   */
  async listSources(
    request?: operations.ListSourcesRequest | undefined,
    options?: RequestOptions,
  ): Promise<operations.ListSourcesResponse> {
    return unwrapAsync(sourcesListSources(
      this,
      request,
      options,
    ));
  }

  /**
   * Get
   */
  async getSource(
    request: operations.GetSourceRequest,
    options?: RequestOptions,
  ): Promise<models.Source> {
    return unwrapAsync(sourcesGetSource(
      this,
      request,
      options,
    ));
  }

  /**
   * Update
   */
  async updateSource(
    request: operations.UpdateSourceRequest,
    options?: RequestOptions,
  ): Promise<models.Source> {
    return unwrapAsync(sourcesUpdateSource(
      this,
      request,
      options,
    ));
  }

  /**
   * List Events
   *
   * @remarks
   * List events for a specific source with optional status filtering
   */
  async listSourceEvents(
    request: operations.ListSourceEventsRequest,
    options?: RequestOptions,
  ): Promise<operations.ListSourceEventsResponse> {
    return unwrapAsync(sourcesListSourceEvents(
      this,
      request,
      options,
    ));
  }

  /**
   * Approve
   *
   * @remarks
   * Approve a pending source event to create a usage event
   */
  async approveSourceEvent(
    request: operations.ApproveSourceEventRequest,
    options?: RequestOptions,
  ): Promise<models.SourceEvent> {
    return unwrapAsync(sourcesApproveSourceEvent(
      this,
      request,
      options,
    ));
  }

  /**
   * Reject
   *
   * @remarks
   * Reject a pending source event
   */
  async rejectSourceEvent(
    request: operations.RejectSourceEventRequest,
    options?: RequestOptions,
  ): Promise<models.SourceEvent> {
    return unwrapAsync(sourcesRejectSourceEvent(
      this,
      request,
      options,
    ));
  }

  /**
   * Bulk Approve
   *
   * @remarks
   * Approve multiple pending source events at once
   */
  async bulkApproveSourceEvents(
    request: operations.BulkApproveSourceEventsRequest,
    options?: RequestOptions,
  ): Promise<operations.BulkApproveSourceEventsResponse> {
    return unwrapAsync(sourcesBulkApproveSourceEvents(
      this,
      request,
      options,
    ));
  }

  /**
   * Bulk Reject
   *
   * @remarks
   * Reject multiple pending source events at once
   */
  async bulkRejectSourceEvents(
    request: operations.BulkRejectSourceEventsRequest,
    options?: RequestOptions,
  ): Promise<operations.BulkRejectSourceEventsResponse> {
    return unwrapAsync(sourcesBulkRejectSourceEvents(
      this,
      request,
      options,
    ));
  }

  /**
   * List Rules
   *
   * @remarks
   * List all auto-acceptance rules for a source. These rules automatically approve pending source events when all conditions are met.
   */
  async listSourceRules(
    request: operations.ListSourceRulesRequest,
    options?: RequestOptions,
  ): Promise<operations.ListSourceRulesResponse> {
    return unwrapAsync(sourcesListSourceRules(
      this,
      request,
      options,
    ));
  }

  /**
   * Create Rule
   *
   * @remarks
   * Create a rule for automatically approving source events. When a pending source event matches ALL conditions in a rule, it will be automatically approved and converted to a usage event. Rules are evaluated in order (lowest order number first), and the first matching rule triggers auto-approval. Maximum 10 rules per source.
   */
  async createSourceRule(
    request: models.CreateRuleRequest,
    options?: RequestOptions,
  ): Promise<models.SourceRule> {
    return unwrapAsync(sourcesCreateSourceRule(
      this,
      request,
      options,
    ));
  }

  /**
   * Get Rule
   */
  async getSourceRule(
    request: operations.GetSourceRuleRequest,
    options?: RequestOptions,
  ): Promise<models.SourceRule> {
    return unwrapAsync(sourcesGetSourceRule(
      this,
      request,
      options,
    ));
  }

  /**
   * Update Rule
   */
  async updateSourceRule(
    request: operations.UpdateSourceRuleRequest,
    options?: RequestOptions,
  ): Promise<models.SourceRule> {
    return unwrapAsync(sourcesUpdateSourceRule(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete Rule
   */
  async deleteSourceRule(
    request: operations.DeleteSourceRuleRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(sourcesDeleteSourceRule(
      this,
      request,
      options,
    ));
  }
}
