/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Percentage pricing model
 */
export type PriceProperties4 = {
  /**
   * Ceiling amount limiting total charge regardless of percentage calculation. Sample values: '500.00' caps fees at $500 maximum, '2000.00' limits charges to $2000 per period
   */
  maxCharge: string;
  /**
   * Floor amount charged regardless of percentage calculation. Sample values: '5.00' ensures minimum $5 fee, '25.00' guarantees at least $25 per billing event
   */
  minCharge: string;
  /**
   * Rate expressed as decimal between 0 and 10, supporting up to 4 decimal precision. Sample values: '0.03' represents 3%, '0.075' represents 7.5%, '1.10' represents 110%
   */
  percentage: string;
};

/**
 * Function used for volume pricing calculations
 */
export const FunctionT = {
  Linear: "linear",
} as const;
/**
 * Function used for volume pricing calculations
 */
export type FunctionT = ClosedEnum<typeof FunctionT>;

export type ParametersT = {
  /**
   * Function used for volume pricing calculations
   */
  function: FunctionT;
  /**
   * Gradient for volume pricing calculations
   */
  gradient: string;
  /**
   * Maximum value for volume pricing
   */
  max: string;
  /**
   * Minimum value for volume pricing
   */
  min: string;
};

/**
 * Volume pricing model
 */
export type PriceProperties3 = {
  /**
   * Default value for volume pricing
   */
  default: string;
  parameters: ParametersT;
};

/**
 * Dynamic pricing model
 */
export type PriceProperties2 = {
  /**
   * Upper limit of the price range for dynamic pricing. Sample values: '0.10' means $0.10 per token for large volumes at peak times
   */
  maxPrice: string;
  /**
   * Lower limit of the price range for dynamic pricing. Sample values: '0.01' means $0.01 per token for low volumes during off-peak hours
   */
  minPrice: string;
};

/**
 * Standard pricing model
 */
export type PriceProperties1 = {
  /**
   * Per-unit cost in decimal format for fixed-rate pricing. Sample values: '0.00002' represents $0.00002 per token, '0.15' represents $0.15 per gigabyte stored, '0.05' represents $0.05 per API call
   */
  unitPrice: string;
};

export type PricePropertiesUnion =
  | PriceProperties4
  | PriceProperties2
  | PriceProperties3
  | PriceProperties1;

/** @internal */
export const PriceProperties4$inboundSchema: z.ZodType<
  PriceProperties4,
  z.ZodTypeDef,
  unknown
> = z.object({
  maxCharge: z.string(),
  minCharge: z.string(),
  percentage: z.string(),
});
/** @internal */
export type PriceProperties4$Outbound = {
  maxCharge: string;
  minCharge: string;
  percentage: string;
};

/** @internal */
export const PriceProperties4$outboundSchema: z.ZodType<
  PriceProperties4$Outbound,
  z.ZodTypeDef,
  PriceProperties4
> = z.object({
  maxCharge: z.string(),
  minCharge: z.string(),
  percentage: z.string(),
});

export function priceProperties4ToJSON(
  priceProperties4: PriceProperties4,
): string {
  return JSON.stringify(
    PriceProperties4$outboundSchema.parse(priceProperties4),
  );
}
export function priceProperties4FromJSON(
  jsonString: string,
): SafeParseResult<PriceProperties4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PriceProperties4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PriceProperties4' from JSON`,
  );
}

/** @internal */
export const FunctionT$inboundSchema: z.ZodNativeEnum<typeof FunctionT> = z
  .nativeEnum(FunctionT);
/** @internal */
export const FunctionT$outboundSchema: z.ZodNativeEnum<typeof FunctionT> =
  FunctionT$inboundSchema;

/** @internal */
export const ParametersT$inboundSchema: z.ZodType<
  ParametersT,
  z.ZodTypeDef,
  unknown
> = z.object({
  function: FunctionT$inboundSchema,
  gradient: z.string(),
  max: z.string(),
  min: z.string(),
});
/** @internal */
export type ParametersT$Outbound = {
  function: string;
  gradient: string;
  max: string;
  min: string;
};

/** @internal */
export const ParametersT$outboundSchema: z.ZodType<
  ParametersT$Outbound,
  z.ZodTypeDef,
  ParametersT
> = z.object({
  function: FunctionT$outboundSchema,
  gradient: z.string(),
  max: z.string(),
  min: z.string(),
});

export function parametersToJSON(parametersT: ParametersT): string {
  return JSON.stringify(ParametersT$outboundSchema.parse(parametersT));
}
export function parametersFromJSON(
  jsonString: string,
): SafeParseResult<ParametersT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParametersT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParametersT' from JSON`,
  );
}

/** @internal */
export const PriceProperties3$inboundSchema: z.ZodType<
  PriceProperties3,
  z.ZodTypeDef,
  unknown
> = z.object({
  default: z.string(),
  parameters: z.lazy(() => ParametersT$inboundSchema),
});
/** @internal */
export type PriceProperties3$Outbound = {
  default: string;
  parameters: ParametersT$Outbound;
};

/** @internal */
export const PriceProperties3$outboundSchema: z.ZodType<
  PriceProperties3$Outbound,
  z.ZodTypeDef,
  PriceProperties3
> = z.object({
  default: z.string(),
  parameters: z.lazy(() => ParametersT$outboundSchema),
});

export function priceProperties3ToJSON(
  priceProperties3: PriceProperties3,
): string {
  return JSON.stringify(
    PriceProperties3$outboundSchema.parse(priceProperties3),
  );
}
export function priceProperties3FromJSON(
  jsonString: string,
): SafeParseResult<PriceProperties3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PriceProperties3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PriceProperties3' from JSON`,
  );
}

/** @internal */
export const PriceProperties2$inboundSchema: z.ZodType<
  PriceProperties2,
  z.ZodTypeDef,
  unknown
> = z.object({
  maxPrice: z.string(),
  minPrice: z.string(),
});
/** @internal */
export type PriceProperties2$Outbound = {
  maxPrice: string;
  minPrice: string;
};

/** @internal */
export const PriceProperties2$outboundSchema: z.ZodType<
  PriceProperties2$Outbound,
  z.ZodTypeDef,
  PriceProperties2
> = z.object({
  maxPrice: z.string(),
  minPrice: z.string(),
});

export function priceProperties2ToJSON(
  priceProperties2: PriceProperties2,
): string {
  return JSON.stringify(
    PriceProperties2$outboundSchema.parse(priceProperties2),
  );
}
export function priceProperties2FromJSON(
  jsonString: string,
): SafeParseResult<PriceProperties2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PriceProperties2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PriceProperties2' from JSON`,
  );
}

/** @internal */
export const PriceProperties1$inboundSchema: z.ZodType<
  PriceProperties1,
  z.ZodTypeDef,
  unknown
> = z.object({
  unitPrice: z.string(),
});
/** @internal */
export type PriceProperties1$Outbound = {
  unitPrice: string;
};

/** @internal */
export const PriceProperties1$outboundSchema: z.ZodType<
  PriceProperties1$Outbound,
  z.ZodTypeDef,
  PriceProperties1
> = z.object({
  unitPrice: z.string(),
});

export function priceProperties1ToJSON(
  priceProperties1: PriceProperties1,
): string {
  return JSON.stringify(
    PriceProperties1$outboundSchema.parse(priceProperties1),
  );
}
export function priceProperties1FromJSON(
  jsonString: string,
): SafeParseResult<PriceProperties1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PriceProperties1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PriceProperties1' from JSON`,
  );
}

/** @internal */
export const PricePropertiesUnion$inboundSchema: z.ZodType<
  PricePropertiesUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => PriceProperties4$inboundSchema),
  z.lazy(() => PriceProperties2$inboundSchema),
  z.lazy(() => PriceProperties3$inboundSchema),
  z.lazy(() => PriceProperties1$inboundSchema),
]);
/** @internal */
export type PricePropertiesUnion$Outbound =
  | PriceProperties4$Outbound
  | PriceProperties2$Outbound
  | PriceProperties3$Outbound
  | PriceProperties1$Outbound;

/** @internal */
export const PricePropertiesUnion$outboundSchema: z.ZodType<
  PricePropertiesUnion$Outbound,
  z.ZodTypeDef,
  PricePropertiesUnion
> = z.union([
  z.lazy(() => PriceProperties4$outboundSchema),
  z.lazy(() => PriceProperties2$outboundSchema),
  z.lazy(() => PriceProperties3$outboundSchema),
  z.lazy(() => PriceProperties1$outboundSchema),
]);

export function pricePropertiesUnionToJSON(
  pricePropertiesUnion: PricePropertiesUnion,
): string {
  return JSON.stringify(
    PricePropertiesUnion$outboundSchema.parse(pricePropertiesUnion),
  );
}
export function pricePropertiesUnionFromJSON(
  jsonString: string,
): SafeParseResult<PricePropertiesUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PricePropertiesUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PricePropertiesUnion' from JSON`,
  );
}
