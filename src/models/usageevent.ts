/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const UsageEventObject = {
  UsageEvent: "usageEvent",
} as const;
export type UsageEventObject = ClosedEnum<typeof UsageEventObject>;

/**
 * Billing information for the usage event when it has been billed. This object is populated by the server and returned in GET and PATCH responses. It cannot be set directly in request bodies.
 */
export type Billing = {
  /**
   * Billing event identifier linked to this consumption record
   */
  billingEventId?: string | undefined;
  /**
   * Three-letter ISO 4217 currency code. Sample values: 'USD' for US dollars, 'EUR' for euros, 'GBP' for British pounds
   */
  currency?: string | undefined;
  /**
   * Invoice V2 period ID (subscription-anchor based billing). Null for legacy billing.
   */
  invoiceId?: string | undefined;
  /**
   * Price amount in the smallest currency unit, excluding tax. Sample values: 1000000000 represents $1.00 in atomic units, 5000000000 represents $5.00 in atomic units
   */
  price?: number | undefined;
  /**
   * Final amount including tax in the smallest currency unit. Sample values: 1085000000 equals $1.085 total (price + tax) in atomic units, 5500000000 equals $5.50 total in atomic units. Calculated as price plus totalTax.
   */
  totalAmount?: number | undefined;
  /**
   * Total tax amount in the smallest currency unit. Sample values: 85000000 represents $0.085 tax in atomic units, 100000000 represents $0.10 tax in atomic units
   */
  totalTax?: number | undefined;
};

export type UsageEventProperty = {
  billableMetricId: string;
  /**
   * Custom price override in decimal dollars. Sample values: '0.000012' sets $0.000012 per unit, '0.50' sets $0.50 per unit, '1.25' sets $1.25 per unit
   */
  price?: string | undefined;
  /**
   * Consumption quantity must be a positive whole number. Sample values: 1 for single unit, 100 for one hundred units, 2500 for tokens consumed
   */
  quantity: number;
};

/**
 * Refund information for the usage event when it has been refunded. This object is populated by the server and returned in GET and PATCH responses. It cannot be set directly in request bodies.
 */
export type Refund = {
  /**
   * Reason for the refund. Sample values: 'Customer request', 'Billing error', 'Service credit', 'System error correction'
   */
  reason?: string | undefined;
  /**
   * Timestamp when the usage event was refunded
   */
  refundedAt?: Date | undefined;
};

export type UsageEvent = {
  /**
   * Unique identifier for a usage event
   */
  id: string;
  object: UsageEventObject;
  /**
   * Billing information for the usage event when it has been billed. This object is populated by the server and returned in GET and PATCH responses. It cannot be set directly in request bodies.
   */
  billing?: Billing | undefined;
  consumerId?: string | undefined;
  createdAt: Date;
  customerId: string;
  /**
   * Readable summary explaining what triggered this consumption event. Sample values: 'Claude language model text generation', 'Customer data warehouse storage allocation', 'DALL-E image creation batch job', 'GPT-4 fine-tuning compute session', 'Vector database query operations'
   */
  description?: string | undefined;
  /**
   * Commitment identifier used for this consumption event. Sample values: 'com_abc123xyz', 'com_789def456'
   */
  entitlementId?: string | undefined;
  idempotencyKey?: string | undefined;
  merchantId: string;
  metadata?: { [k: string]: string } | undefined;
  properties: Array<UsageEventProperty>;
  /**
   * Refund information for the usage event when it has been refunded. This object is populated by the server and returned in GET and PATCH responses. It cannot be set directly in request bodies.
   */
  refund?: Refund | undefined;
  subscriptionId: string;
  timestamp: Date;
};

/** @internal */
export const UsageEventObject$inboundSchema: z.ZodNativeEnum<
  typeof UsageEventObject
> = z.nativeEnum(UsageEventObject);

/** @internal */
export const Billing$inboundSchema: z.ZodType<Billing, z.ZodTypeDef, unknown> =
  z.object({
    billingEventId: z.string().optional(),
    currency: z.string().optional(),
    invoiceId: z.string().optional(),
    price: z.number().int().optional(),
    totalAmount: z.number().int().optional(),
    totalTax: z.number().int().optional(),
  });

export function billingFromJSON(
  jsonString: string,
): SafeParseResult<Billing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Billing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Billing' from JSON`,
  );
}

/** @internal */
export const UsageEventProperty$inboundSchema: z.ZodType<
  UsageEventProperty,
  z.ZodTypeDef,
  unknown
> = z.object({
  billableMetricId: z.string(),
  price: z.string().optional(),
  quantity: z.number().int(),
});

export function usageEventPropertyFromJSON(
  jsonString: string,
): SafeParseResult<UsageEventProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsageEventProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsageEventProperty' from JSON`,
  );
}

/** @internal */
export const Refund$inboundSchema: z.ZodType<Refund, z.ZodTypeDef, unknown> = z
  .object({
    reason: z.string().optional(),
    refundedAt: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
  });

export function refundFromJSON(
  jsonString: string,
): SafeParseResult<Refund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refund' from JSON`,
  );
}

/** @internal */
export const UsageEvent$inboundSchema: z.ZodType<
  UsageEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: UsageEventObject$inboundSchema,
  billing: z.lazy(() => Billing$inboundSchema).optional(),
  consumerId: z.string().optional(),
  createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  customerId: z.string(),
  description: z.string().optional(),
  entitlementId: z.string().optional(),
  idempotencyKey: z.string().optional(),
  merchantId: z.string(),
  metadata: z.record(z.string()).optional(),
  properties: z.array(z.lazy(() => UsageEventProperty$inboundSchema)),
  refund: z.lazy(() => Refund$inboundSchema).optional(),
  subscriptionId: z.string(),
  timestamp: z.string().datetime({ offset: true }).transform(v => new Date(v)),
});

export function usageEventFromJSON(
  jsonString: string,
): SafeParseResult<UsageEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsageEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsageEvent' from JSON`,
  );
}
