/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const SubscriptionObject = {
  Subscription: "subscription",
} as const;
export type SubscriptionObject = ClosedEnum<typeof SubscriptionObject>;

/**
 * Breakdown of payment amount
 */
export type Breakdown = {
  /**
   * One-time flat fee charges in decimal dollar format. Sample values: '50.00' equals $50.00 setup fee, '100.00' equals $100.00 activation fee
   */
  upfrontCharges: string;
  /**
   * Wallet charge amount in decimal dollar format. This is the calculated difference between the minimum account balance requirement and the customer's current balance. If the customer already has sufficient balance, this will be '0.00'. Sample values: '200.00' equals $200.00 charge, '0.00' means no charge needed
   */
  walletCharge: string;
};

/**
 * Payment status
 */
export const StatusPending = {
  Pending: "pending",
} as const;
/**
 * Payment status
 */
export type StatusPending = ClosedEnum<typeof StatusPending>;

/**
 * Payment session details when upfront payment is required
 */
export type Payment = {
  /**
   * Total payment amount in decimal dollar format. Sample values: '250.00' equals $250.00, '99.99' equals $99.99
   */
  amount: string;
  /**
   * Breakdown of payment amount
   */
  breakdown: Breakdown;
  /**
   * Checkout page URL for customer payment completion. Sample values: 'https://checkout.paygentic.com/session/ps_abc123', 'https://pay.example.com/checkout/xyz789'
   */
  checkoutUrl: string;
  /**
   * Payment session identifier for upfront payment processing. Sample values: 'ps_abc123xyz', 'ps_789def456'
   */
  paymentSessionId: string;
  /**
   * Payment status
   */
  status: StatusPending;
};

export const SubscriptionStatus = {
  PendingPayment: "pending_payment",
  Active: "active",
  Terminated: "terminated",
} as const;
export type SubscriptionStatus = ClosedEnum<typeof SubscriptionStatus>;

export type Subscription = {
  id: string;
  object: SubscriptionObject;
  /**
   * Whether automatic charging is enabled for this subscription. When true, invoices will be automatically paid using stored payment methods.
   */
  autoCharge: boolean;
  createdAt: Date;
  customerId: string;
  endingAt?: Date | undefined;
  /**
   * Projected tax percentage rate. Sample values: 8.875 indicates 8.875% tax rate, 10.0 indicates 10% tax rate, 0 indicates no tax applied
   */
  estimatedTaxRate?: number | undefined;
  /**
   * When true, tax rate is forced to 0%.
   */
  taxExempt: boolean;
  name: string;
  /**
   * Payment session details when upfront payment is required
   */
  payment?: Payment | undefined;
  planId: string;
  /**
   * @deprecated Use minimumAccountBalance instead. Minimum required wallet balance in atomic units. Sample values: '200000000000' equals $200.00 minimum, '1000000000000' equals $1000.00 minimum
   */
  prefundAmount?: string | undefined;
  /**
   * Minimum wallet balance requirement in nanodollars. Can be '0' to disable. The system calculates the difference between this minimum and the customer's current balance, charging only what's needed to reach the minimum. Note: If the calculated charge amount is below payment processor minimums (typically $1.00), the actual charged amount may be automatically adjusted upward to meet the minimum requirement. Sample values: '200000000000' equals $200.00 minimum, '1000000000000' equals $1000.00 minimum
   */
  minimumAccountBalance?: string | undefined;
  startedAt: Date;
  status: SubscriptionStatus;
  terminatedAt?: Date | undefined;
  /**
   * ID of who terminated the subscription (customer ID or merchant ID)
   */
  terminatedBy?: string | undefined;
  /**
   * Reason for termination
   */
  terminationReason?: string | undefined;
  /**
   * Test clock ID if this subscription is attached to a test clock. Only present in non-production environments.
   */
  testClockId?: string | undefined;
  updatedAt: Date;
  /**
   * Optional (virtual) wallet ID for the subscription
   */
  walletId?: string | undefined;
  /**
   * Whether renewal reminder emails are enabled for this subscription. Null means use plan default.
   */
  renewalReminderEnabled?: boolean | null | undefined;
  /**
   * Number of days before renewal to send the reminder. Null means use plan default.
   */
  renewalReminderDays?: number | null | undefined;
};

/** @internal */
export const SubscriptionObject$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionObject
> = z.nativeEnum(SubscriptionObject);

/** @internal */
export const Breakdown$inboundSchema: z.ZodType<
  Breakdown,
  z.ZodTypeDef,
  unknown
> = z.object({
  upfrontCharges: z.string(),
  walletCharge: z.string(),
});

export function breakdownFromJSON(
  jsonString: string,
): SafeParseResult<Breakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Breakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Breakdown' from JSON`,
  );
}

/** @internal */
export const StatusPending$inboundSchema: z.ZodNativeEnum<
  typeof StatusPending
> = z.nativeEnum(StatusPending);

/** @internal */
export const Payment$inboundSchema: z.ZodType<Payment, z.ZodTypeDef, unknown> =
  z.object({
    amount: z.string(),
    breakdown: z.lazy(() => Breakdown$inboundSchema),
    checkoutUrl: z.string(),
    paymentSessionId: z.string(),
    status: StatusPending$inboundSchema,
  });

export function paymentFromJSON(
  jsonString: string,
): SafeParseResult<Payment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Payment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Payment' from JSON`,
  );
}

/** @internal */
export const SubscriptionStatus$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionStatus
> = z.nativeEnum(SubscriptionStatus);

/** @internal */
export const Subscription$inboundSchema: z.ZodType<
  Subscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: SubscriptionObject$inboundSchema,
  autoCharge: z.boolean().default(false),
  createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  customerId: z.string(),
  endingAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  estimatedTaxRate: z.number().optional(),
  taxExempt: z.boolean().default(false),
  name: z.string(),
  payment: z.lazy(() => Payment$inboundSchema).optional(),
  planId: z.string(),
  prefundAmount: z.string().optional(),
  minimumAccountBalance: z.string().optional(),
  startedAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  status: SubscriptionStatus$inboundSchema,
  terminatedAt: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  terminatedBy: z.string().optional(),
  terminationReason: z.string().optional(),
  testClockId: z.string().optional(),
  updatedAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  walletId: z.string().optional(),
  renewalReminderEnabled: z.nullable(z.boolean()).optional(),
  renewalReminderDays: z.nullable(z.number().int()).optional(),
});

export function subscriptionFromJSON(
  jsonString: string,
): SafeParseResult<Subscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription' from JSON`,
  );
}
