/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import * as models from "../index.js";

/**
 * The pricing model to be used, which can be standard, dynamic, volume-based, or percentage-based.
 */
export const UpdatePriceModel = {
  Standard: "standard",
  Dynamic: "dynamic",
  Volume: "volume",
  Percentage: "percentage",
} as const;
/**
 * The pricing model to be used, which can be standard, dynamic, volume-based, or percentage-based.
 */
export type UpdatePriceModel = ClosedEnum<typeof UpdatePriceModel>;

/**
 * Billing timing preference. For billable metrics: 'instant' (charges immediately) or 'in_arrears' (charges at period end). For fees: 'in_advance' (charges upfront) or 'in_arrears' (charges at period end).
 */
export const UpdatePricePaymentTerm = {
  Instant: "instant",
  InArrears: "in_arrears",
  InAdvance: "in_advance",
} as const;
/**
 * Billing timing preference. For billable metrics: 'instant' (charges immediately) or 'in_arrears' (charges at period end). For fees: 'in_advance' (charges upfront) or 'in_arrears' (charges at period end).
 */
export type UpdatePricePaymentTerm = ClosedEnum<typeof UpdatePricePaymentTerm>;

export type UpdatePriceRequestBody = {
  /**
   * Unique identifier for a billable metric
   */
  billableMetricId?: string | undefined;
  /**
   * Updated invoice line item label. Sample values: 'LLM Token Usage', 'Storage Charges', 'API Call Fees'
   */
  invoiceDisplayName?: string | undefined;
  /**
   * The pricing model to be used, which can be standard, dynamic, volume-based, or percentage-based.
   */
  model?: UpdatePriceModel | undefined;
  properties?: models.PricePropertiesUnion | undefined;
  /**
   * Billing timing preference. For billable metrics: 'instant' (charges immediately) or 'in_arrears' (charges at period end). For fees: 'in_advance' (charges upfront) or 'in_arrears' (charges at period end).
   */
  paymentTerm?: UpdatePricePaymentTerm | undefined;
  /**
   * ISO 8601 duration for recurring fees (e.g., 'P1M' for monthly, 'P1Y' for yearly, or 'P0D' for one-time)
   */
  billingCadence?: string | null | undefined;
  /**
   * Feature to associate. Set to null to remove existing feature. Omit to leave unchanged.
   */
  feature?: models.PriceFeatureInput | null | undefined;
};

export type UpdatePriceRequest = {
  /**
   * The unique identifier of the price
   */
  id: string;
  requestBody: UpdatePriceRequestBody;
};

/** @internal */
export const UpdatePriceModel$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePriceModel
> = z.nativeEnum(UpdatePriceModel);

/** @internal */
export const UpdatePricePaymentTerm$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePricePaymentTerm
> = z.nativeEnum(UpdatePricePaymentTerm);

/** @internal */
export type UpdatePriceRequestBody$Outbound = {
  billableMetricId?: string | undefined;
  invoiceDisplayName?: string | undefined;
  model?: string | undefined;
  properties?: models.PricePropertiesUnion$Outbound | undefined;
  paymentTerm?: string | undefined;
  billingCadence?: string | null | undefined;
  feature?: models.PriceFeatureInput$Outbound | null | undefined;
};

/** @internal */
export const UpdatePriceRequestBody$outboundSchema: z.ZodType<
  UpdatePriceRequestBody$Outbound,
  z.ZodTypeDef,
  UpdatePriceRequestBody
> = z.object({
  billableMetricId: z.string().optional(),
  invoiceDisplayName: z.string().optional(),
  model: UpdatePriceModel$outboundSchema.optional(),
  properties: models.PricePropertiesUnion$outboundSchema.optional(),
  paymentTerm: UpdatePricePaymentTerm$outboundSchema.optional(),
  billingCadence: z.nullable(z.string()).optional(),
  feature: z.nullable(models.PriceFeatureInput$outboundSchema).optional(),
});

export function updatePriceRequestBodyToJSON(
  updatePriceRequestBody: UpdatePriceRequestBody,
): string {
  return JSON.stringify(
    UpdatePriceRequestBody$outboundSchema.parse(updatePriceRequestBody),
  );
}

/** @internal */
export type UpdatePriceRequest$Outbound = {
  id: string;
  RequestBody: UpdatePriceRequestBody$Outbound;
};

/** @internal */
export const UpdatePriceRequest$outboundSchema: z.ZodType<
  UpdatePriceRequest$Outbound,
  z.ZodTypeDef,
  UpdatePriceRequest
> = z.object({
  id: z.string(),
  requestBody: z.lazy(() => UpdatePriceRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updatePriceRequestToJSON(
  updatePriceRequest: UpdatePriceRequest,
): string {
  return JSON.stringify(
    UpdatePriceRequest$outboundSchema.parse(updatePriceRequest),
  );
}
