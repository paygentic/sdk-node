/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * The comparison operator to use
 */
export const Operator = {
  Equals: "equals",
  Contains: "contains",
  Between: "between",
  GreaterThan: "greaterThan",
  LessThan: "lessThan",
  Domain: "domain",
} as const;
/**
 * The comparison operator to use
 */
export type Operator = ClosedEnum<typeof Operator>;

/**
 * The type of field to evaluate
 */
export const RuleConditionType = {
  Date: "date",
  CustomerName: "customerName",
  CustomerEmail: "customerEmail",
  Amount: "amount",
} as const;
/**
 * The type of field to evaluate
 */
export type RuleConditionType = ClosedEnum<typeof RuleConditionType>;

export type From = string | number;

export type To = string | number;

export type Value = {
  from: string | number;
  to: string | number;
};

/**
 * The value to compare against
 */
export type ValueUnion = Value | string | number;

/**
 * A single condition that must be met for a rule to trigger auto-acceptance. Multiple conditions in a rule use AND logic.
 */
export type RuleCondition = {
  /**
   * The comparison operator to use
   */
  operator: Operator;
  /**
   * The type of field to evaluate
   */
  type: RuleConditionType;
  /**
   * The value to compare against
   */
  value: Value | string | number;
};

/** @internal */
export const Operator$inboundSchema: z.ZodNativeEnum<typeof Operator> = z
  .nativeEnum(Operator);
/** @internal */
export const Operator$outboundSchema: z.ZodNativeEnum<typeof Operator> =
  Operator$inboundSchema;

/** @internal */
export const RuleConditionType$inboundSchema: z.ZodNativeEnum<
  typeof RuleConditionType
> = z.nativeEnum(RuleConditionType);
/** @internal */
export const RuleConditionType$outboundSchema: z.ZodNativeEnum<
  typeof RuleConditionType
> = RuleConditionType$inboundSchema;

/** @internal */
export const From$inboundSchema: z.ZodType<From, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number()]);
/** @internal */
export type From$Outbound = string | number;

/** @internal */
export const From$outboundSchema: z.ZodType<From$Outbound, z.ZodTypeDef, From> =
  z.union([z.string(), z.number()]);

export function fromToJSON(from: From): string {
  return JSON.stringify(From$outboundSchema.parse(from));
}
export function fromFromJSON(
  jsonString: string,
): SafeParseResult<From, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => From$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'From' from JSON`,
  );
}

/** @internal */
export const To$inboundSchema: z.ZodType<To, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
]);
/** @internal */
export type To$Outbound = string | number;

/** @internal */
export const To$outboundSchema: z.ZodType<To$Outbound, z.ZodTypeDef, To> = z
  .union([z.string(), z.number()]);

export function toToJSON(to: To): string {
  return JSON.stringify(To$outboundSchema.parse(to));
}
export function toFromJSON(
  jsonString: string,
): SafeParseResult<To, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => To$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'To' from JSON`,
  );
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z
  .object({
    from: z.union([z.string(), z.number()]),
    to: z.union([z.string(), z.number()]),
  });
/** @internal */
export type Value$Outbound = {
  from: string | number;
  to: string | number;
};

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = z.object({
  from: z.union([z.string(), z.number()]),
  to: z.union([z.string(), z.number()]),
});

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}
export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const ValueUnion$inboundSchema: z.ZodType<
  ValueUnion,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => Value$inboundSchema), z.string(), z.number()]);
/** @internal */
export type ValueUnion$Outbound = Value$Outbound | string | number;

/** @internal */
export const ValueUnion$outboundSchema: z.ZodType<
  ValueUnion$Outbound,
  z.ZodTypeDef,
  ValueUnion
> = z.union([z.lazy(() => Value$outboundSchema), z.string(), z.number()]);

export function valueUnionToJSON(valueUnion: ValueUnion): string {
  return JSON.stringify(ValueUnion$outboundSchema.parse(valueUnion));
}
export function valueUnionFromJSON(
  jsonString: string,
): SafeParseResult<ValueUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueUnion' from JSON`,
  );
}

/** @internal */
export const RuleCondition$inboundSchema: z.ZodType<
  RuleCondition,
  z.ZodTypeDef,
  unknown
> = z.object({
  operator: Operator$inboundSchema,
  type: RuleConditionType$inboundSchema,
  value: z.union([z.lazy(() => Value$inboundSchema), z.string(), z.number()]),
});
/** @internal */
export type RuleCondition$Outbound = {
  operator: string;
  type: string;
  value: Value$Outbound | string | number;
};

/** @internal */
export const RuleCondition$outboundSchema: z.ZodType<
  RuleCondition$Outbound,
  z.ZodTypeDef,
  RuleCondition
> = z.object({
  operator: Operator$outboundSchema,
  type: RuleConditionType$outboundSchema,
  value: z.union([z.lazy(() => Value$outboundSchema), z.string(), z.number()]),
});

export function ruleConditionToJSON(ruleCondition: RuleCondition): string {
  return JSON.stringify(RuleCondition$outboundSchema.parse(ruleCondition));
}
export function ruleConditionFromJSON(
  jsonString: string,
): SafeParseResult<RuleCondition, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RuleCondition$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RuleCondition' from JSON`,
  );
}
