/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const BillableMetricObject = {
  BillableMetric: "billableMetric",
} as const;
export type BillableMetricObject = ClosedEnum<typeof BillableMetricObject>;

export const Aggregation = {
  Sum: "SUM",
  Count: "COUNT",
  Avg: "AVG",
  Min: "MIN",
  Max: "MAX",
  UniqueCount: "UNIQUE_COUNT",
  Latest: "LATEST",
} as const;
export type Aggregation = ClosedEnum<typeof Aggregation>;

export type BillableMetric = {
  /**
   * Unique identifier for a billable metric
   */
  id: string;
  object: BillableMetricObject;
  aggregation: Aggregation;
  createdAt: Date;
  description: string;
  /**
   * Unique identifier for an organization
   */
  merchantId: string;
  name: string;
  /**
   * Unique identifier for a product
   */
  productId: string;
  unit: string;
  updatedAt: Date;
  eventType?: string | null | undefined;
  valueProperty?: string | null | undefined;
  groupBy?: { [k: string]: string } | null | undefined;
  eventFrom?: Date | null | undefined;
};

/** @internal */
export const BillableMetricObject$inboundSchema: z.ZodNativeEnum<
  typeof BillableMetricObject
> = z.nativeEnum(BillableMetricObject);

/** @internal */
export const Aggregation$inboundSchema: z.ZodNativeEnum<typeof Aggregation> = z
  .nativeEnum(Aggregation);

/** @internal */
export const BillableMetric$inboundSchema: z.ZodType<
  BillableMetric,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: BillableMetricObject$inboundSchema.default("billableMetric"),
  aggregation: Aggregation$inboundSchema,
  createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  description: z.string(),
  merchantId: z.string(),
  name: z.string(),
  productId: z.string(),
  unit: z.string(),
  updatedAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  eventType: z.nullable(z.string()).optional(),
  valueProperty: z.nullable(z.string()).optional(),
  groupBy: z.nullable(z.record(z.string())).optional(),
  eventFrom: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
});

export function billableMetricFromJSON(
  jsonString: string,
): SafeParseResult<BillableMetric, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillableMetric$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillableMetric' from JSON`,
  );
}
