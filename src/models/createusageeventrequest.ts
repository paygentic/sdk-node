/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";

export type CreateUsageEventRequestProperty = {
  /**
   * Identifier for the consumption metric being reported. Sample metrics: token consumption, storage capacity, inference requests, training hours, data transfer volume
   */
  billableMetricId: string;
  /**
   * Custom per-unit price in decimal format. The total charge is calculated as price Ã— quantity. Sample values: '0.125' sets $0.125 per unit, '2.50' sets $2.50 per unit. Must be within the minPrice and maxPrice bounds defined for the dynamic price model.
   */
  price?: string | undefined;
  /**
   * Measured consumption amount for this metric. Must be a positive whole number. Sample values: 2500 tokens consumed, 42 gigabytes stored, 750 API calls executed, 8 compute hours utilized, 120 images generated
   */
  quantity: number;
};

export type CreateUsageEventRequest = {
  /**
   * Customer identifier that generated this consumption event. Sample values: 'cus_abc123xyz', 'cus_789def456'
   */
  customerId: string;
  /**
   * Commitment identifier for this consumption event. Sample values: 'com_abc123xyz', 'com_789def456'
   */
  entitlementId?: string | undefined;
  /**
   * Unique deduplication key preventing duplicate event processing. Sample values: 'usg_2024_01_15_abc123', 'event_wallet_xyz789', 'consumption_ref_456def'
   */
  idempotencyKey: string;
  /**
   * Merchant organization identifier owning this consumption event. Sample values: 'org_abc123xyz', 'org_789def456'
   */
  merchantId: string;
  /**
   * Custom key-value attributes providing context about the consumption event. Sample values: {"model_name": "claude-3-opus", "input_tokens": "1500", "output_tokens": "800"} or {"storage_tier": "premium", "data_center": "eu-west-1", "encryption": "enabled"} or {"image_resolution": "1024x1024", "generation_model": "stable-diffusion-xl"}
   */
  metadata?: { [k: string]: string } | undefined;
  properties: Array<CreateUsageEventRequestProperty>;
  /**
   * Actual occurrence timestamp for the consumption event in ISO 8601 format. Sample values: '2024-01-15T10:30:00Z', '2024-02-01T14:45:30Z'. Represents when the event occurred, not when Paygentic received it.
   */
  timestamp: Date;
};

/** @internal */
export type CreateUsageEventRequestProperty$Outbound = {
  billableMetricId: string;
  price?: string | undefined;
  quantity: number;
};

/** @internal */
export const CreateUsageEventRequestProperty$outboundSchema: z.ZodType<
  CreateUsageEventRequestProperty$Outbound,
  z.ZodTypeDef,
  CreateUsageEventRequestProperty
> = z.object({
  billableMetricId: z.string(),
  price: z.string().optional(),
  quantity: z.number().int(),
});

export function createUsageEventRequestPropertyToJSON(
  createUsageEventRequestProperty: CreateUsageEventRequestProperty,
): string {
  return JSON.stringify(
    CreateUsageEventRequestProperty$outboundSchema.parse(
      createUsageEventRequestProperty,
    ),
  );
}

/** @internal */
export type CreateUsageEventRequest$Outbound = {
  customerId: string;
  entitlementId?: string | undefined;
  idempotencyKey: string;
  merchantId: string;
  metadata?: { [k: string]: string } | undefined;
  properties: Array<CreateUsageEventRequestProperty$Outbound>;
  timestamp: string;
};

/** @internal */
export const CreateUsageEventRequest$outboundSchema: z.ZodType<
  CreateUsageEventRequest$Outbound,
  z.ZodTypeDef,
  CreateUsageEventRequest
> = z.object({
  customerId: z.string(),
  entitlementId: z.string().optional(),
  idempotencyKey: z.string(),
  merchantId: z.string(),
  metadata: z.record(z.string()).optional(),
  properties: z.array(
    z.lazy(() => CreateUsageEventRequestProperty$outboundSchema),
  ),
  timestamp: z.date().transform(v => v.toISOString()),
});

export function createUsageEventRequestToJSON(
  createUsageEventRequest: CreateUsageEventRequest,
): string {
  return JSON.stringify(
    CreateUsageEventRequest$outboundSchema.parse(createUsageEventRequest),
  );
}
