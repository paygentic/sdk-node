/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  InvoiceLineItem,
  InvoiceLineItem$inboundSchema,
} from "./invoicelineitem.js";

/**
 * The object type
 */
export const InvoiceObject = {
  Invoice: "invoice",
} as const;
/**
 * The object type
 */
export type InvoiceObject = ClosedEnum<typeof InvoiceObject>;

/**
 * Line items (only present if expand=lineItems query parameter is provided)
 */
export type LineItems = {
  /**
   * The invoice ID
   */
  invoiceId: string;
  /**
   * Array of line items for this page
   */
  lineItems: Array<InvoiceLineItem>;
  /**
   * Token for fetching the next page, null if no more pages
   */
  nextPageToken?: string | null | undefined;
  /**
   * Total number of line items across all pages
   */
  totalCount: number;
};

/**
 * The current status of the invoice
 */
export const InvoiceStatus = {
  Active: "ACTIVE",
  Closing: "CLOSING",
  Closed: "CLOSED",
  Calculating: "CALCULATING",
  Draft: "DRAFT",
  Issued: "ISSUED",
  PaymentFailed: "PAYMENT_FAILED",
  Paid: "PAID",
  Cancelled: "CANCELLED",
  WrittenOff: "WRITTEN_OFF",
  Failed: "FAILED",
} as const;
/**
 * The current status of the invoice
 */
export type InvoiceStatus = ClosedEnum<typeof InvoiceStatus>;

/**
 * Tax reconciliation metadata (only present when plan has taxEnabled)
 */
export type Tax = {
  /**
   * Actual tax calculated (in atomic units)
   */
  actualTax?: string | undefined;
  /**
   * Whether wallet adjustment was applied during tax reconciliation
   */
  adjustmentApplied?: boolean | undefined;
  /**
   * Whether wallet adjustment is needed (difference >= $0.01)
   */
  adjustmentNeeded?: boolean | undefined;
  /**
   * Difference between actual and estimated (in atomic units)
   */
  difference?: string | undefined;
  /**
   * Tax estimated from subscription rate (in atomic units)
   */
  estimatedTax?: string | undefined;
  /**
   * Whether reconciliation was performed
   */
  reconciled?: boolean | undefined;
  /**
   * When reconciliation occurred
   */
  reconciledAt?: Date | undefined;
};

export type Invoice = {
  /**
   * The invoice ID
   */
  id: string;
  /**
   * The object type
   */
  object: InvoiceObject;
  /**
   * Whether this invoice auto-approves after calculation
   */
  autoApprove: boolean;
  /**
   * The billing anchor date used for period calculations
   */
  billingAnchor: Date;
  /**
   * ISO 8601 duration string for billing frequency
   */
  billingCadence: string;
  /**
   * When the invoice was created
   */
  createdAt: Date;
  /**
   * ISO 4217 currency code (e.g., USD, EUR)
   */
  currency: string;
  /**
   * The end of the grace period for accepting usage events
   */
  gracePeriodEnd: Date;
  /**
   * Grand total (subtotal + tax) in decimal dollars (real-time for ACTIVE/CLOSING/CLOSED, cached otherwise)
   */
  grandTotal: string;
  /**
   * The invoice number
   */
  invoiceNumber?: string | null | undefined;
  /**
   * Number of billing items (real-time for ACTIVE/CLOSING/CLOSED, cached otherwise)
   */
  itemCount: number;
  /**
   * Line items (only present if expand=lineItems query parameter is provided)
   */
  lineItems?: LineItems | null | undefined;
  /**
   * The merchant organization ID
   */
  merchantId: string;
  /**
   * Additional metadata including transition history
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * When the next scheduled action should occur
   */
  nextActionAt?: Date | null | undefined;
  /**
   * Amount already paid via wallet (account_type='main') in decimal dollars
   */
  paidAmount: string;
  /**
   * When the invoice was paid (null if not yet paid)
   */
  paidAt?: Date | null | undefined;
  /**
   * Payment URL for completing payment (only present when status is ISSUED and unpaidAmount > 0)
   */
  paymentUrl?: string | null | undefined;
  /**
   * Direct PDF download link for tax invoice
   */
  pdfUrl?: string | null | undefined;
  /**
   * The end of the billing period
   */
  periodEnd: Date;
  /**
   * The start of the billing period
   */
  periodStart: Date;
  /**
   * Public URL to view tax invoice
   */
  permalink?: string | null | undefined;
  /**
   * The sequence number of this invoice period
   */
  sequenceNumber: number;
  /**
   * The current status of the invoice
   */
  status: InvoiceStatus;
  /**
   * The subscription ID this invoice belongs to
   */
  subscriptionId: string;
  /**
   * Subtotal in decimal dollars (real-time for ACTIVE/CLOSING/CLOSED, cached otherwise)
   */
  subtotal: string;
  /**
   * Tax reconciliation metadata (only present when plan has taxEnabled)
   */
  tax?: Tax | null | undefined;
  /**
   * Total tax in decimal dollars (real-time for ACTIVE/CLOSING/CLOSED, cached otherwise)
   */
  totalTax: string;
  /**
   * Amount accrued as liability (account_type='usage') in decimal dollars
   */
  unpaidAmount: string;
  /**
   * When the invoice was last updated
   */
  updatedAt: Date;
};

/** @internal */
export const InvoiceObject$inboundSchema: z.ZodNativeEnum<
  typeof InvoiceObject
> = z.nativeEnum(InvoiceObject);

/** @internal */
export const LineItems$inboundSchema: z.ZodType<
  LineItems,
  z.ZodTypeDef,
  unknown
> = z.object({
  invoiceId: z.string(),
  lineItems: z.array(InvoiceLineItem$inboundSchema),
  nextPageToken: z.nullable(z.string()).optional(),
  totalCount: z.number().int(),
});

export function lineItemsFromJSON(
  jsonString: string,
): SafeParseResult<LineItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LineItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LineItems' from JSON`,
  );
}

/** @internal */
export const InvoiceStatus$inboundSchema: z.ZodNativeEnum<
  typeof InvoiceStatus
> = z.nativeEnum(InvoiceStatus);

/** @internal */
export const Tax$inboundSchema: z.ZodType<Tax, z.ZodTypeDef, unknown> = z
  .object({
    actualTax: z.string().optional(),
    adjustmentApplied: z.boolean().optional(),
    adjustmentNeeded: z.boolean().optional(),
    difference: z.string().optional(),
    estimatedTax: z.string().optional(),
    reconciled: z.boolean().optional(),
    reconciledAt: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
  });

export function taxFromJSON(
  jsonString: string,
): SafeParseResult<Tax, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tax$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tax' from JSON`,
  );
}

/** @internal */
export const Invoice$inboundSchema: z.ZodType<Invoice, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    object: InvoiceObject$inboundSchema,
    autoApprove: z.boolean(),
    billingAnchor: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    billingCadence: z.string(),
    createdAt: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    currency: z.string(),
    gracePeriodEnd: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    grandTotal: z.string(),
    invoiceNumber: z.nullable(z.string()).optional(),
    itemCount: z.number().int(),
    lineItems: z.nullable(z.lazy(() => LineItems$inboundSchema)).optional(),
    merchantId: z.string(),
    metadata: z.record(z.any()).optional(),
    nextActionAt: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    paidAmount: z.string(),
    paidAt: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    paymentUrl: z.nullable(z.string()).optional(),
    pdfUrl: z.nullable(z.string()).optional(),
    periodEnd: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    periodStart: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    permalink: z.nullable(z.string()).optional(),
    sequenceNumber: z.number().int(),
    status: InvoiceStatus$inboundSchema,
    subscriptionId: z.string(),
    subtotal: z.string(),
    tax: z.nullable(z.lazy(() => Tax$inboundSchema)).optional(),
    totalTax: z.string(),
    unpaidAmount: z.string(),
    updatedAt: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
  });

export function invoiceFromJSON(
  jsonString: string,
): SafeParseResult<Invoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Invoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Invoice' from JSON`,
  );
}
