/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { Address, Address$inboundSchema } from "./address.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ValidTaxAddress,
  ValidTaxAddress$inboundSchema,
} from "./validtaxaddress.js";

export const CustomerObject = {
  Customer: "customer",
} as const;
export type CustomerObject = ClosedEnum<typeof CustomerObject>;

export type CustomerOrganization = {
  id: string;
  address?: Address | undefined;
  billingEmail?: string | undefined;
  name: string;
  phone?: string | undefined;
};

export type Customer = {
  /**
   * Unique identifier for a customer
   */
  id: string;
  object: CustomerObject;
  /**
   * Unique identifier for an organization
   */
  consumerId: string;
  createdAt: Date;
  /**
   * Unique identifier for an organization
   */
  merchantId: string;
  organization?: CustomerOrganization | undefined;
  /**
   * Business tax registration identifier. Sample values: 'GB123456789' for UK VAT, 'DE123456789' for German VAT, 'FR12345678901' for French VAT. Enables inter-company tax handling and exemption from standard tax collection.
   */
  taxId?: string | undefined;
  /**
   * An object mapping plan IDs, metric IDs, or 'default' to a tax rate percentage (e.g., 13 for 13%)
   */
  taxRates?: { [k: string]: number } | undefined;
  updatedAt: Date;
  /**
   * Indicates whether the consumer address is valid for tax calculation when using Paygentic Tax. If valid=false, tax calculation will be skipped and internal invoice flow with default tax rate will be used.
   */
  validTaxAddress: ValidTaxAddress;
};

/** @internal */
export const CustomerObject$inboundSchema: z.ZodNativeEnum<
  typeof CustomerObject
> = z.nativeEnum(CustomerObject);

/** @internal */
export const CustomerOrganization$inboundSchema: z.ZodType<
  CustomerOrganization,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  address: Address$inboundSchema.optional(),
  billingEmail: z.string().optional(),
  name: z.string(),
  phone: z.string().optional(),
});

export function customerOrganizationFromJSON(
  jsonString: string,
): SafeParseResult<CustomerOrganization, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerOrganization$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerOrganization' from JSON`,
  );
}

/** @internal */
export const Customer$inboundSchema: z.ZodType<
  Customer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: CustomerObject$inboundSchema.default("customer"),
  consumerId: z.string(),
  createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  merchantId: z.string(),
  organization: z.lazy(() => CustomerOrganization$inboundSchema).optional(),
  taxId: z.string().optional(),
  taxRates: z.record(z.number()).optional(),
  updatedAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  validTaxAddress: ValidTaxAddress$inboundSchema,
});

export function customerFromJSON(
  jsonString: string,
): SafeParseResult<Customer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Customer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Customer' from JSON`,
  );
}
